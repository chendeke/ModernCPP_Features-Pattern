#include<iostream>
#include<string>
#include<memory>
using namespace std;
/* 1. C++ 11: Compiler generated function */
/*
* C++ 03:
* 1. Default Constructor (generated only if no constructor is declared by the user)
* 2. Copy Constructor (C++ 11: generated only if no 3, 4, 5, 6 is declared by the user)
* 3. Copy Assignment Operator (C++ 11:generated only if no 2, 4, 5, 6 is declared by the user)
* 4. Destructor 
*
* C++ 11:
* 5. Move Constructor (C++ 11: generated only if no 2, 3, 4, 6 is declared by the user)
* 6. Move Assignment Operator (C++ 11: generated only if no 2, 3, 4, 5 is declared by the user)
 */
class dog {}; //1, 2, 3, 4, 5, 6 will be generated by the compiler
//is euqivalent to:
class dog{
    //C++ 03:
    dog();
    dog(const dog& d);
    dog& operator=(const dog& d);
    ~dog();
    //c++ 11:
    dog(const dog&& d);
    dog& operator=(dog&& d);
};

class cat{ //3, 4 will be generated by compiler. (3 is deprecated)
    cat(const cat& c); //copy constructor. 
};

class Duck{ // 4 will be generated by compiler
    Duck(Duck&& d); //Move constructor
};

class Frog{ // 4 ...
    Frog(Frog&& f, int x = 0);//Move constructor
    Frog(int x = 0); //Default constructor
    Frog(Frog& f, int x = 0) //Copy Constructor
};

class Fish{ // 1, 2, 3 ... (2, 3 are deprecated)
    ~Fish(); //Destructor
};

class Cow{ // 1, 2, 4 ... (2 is deprecated. Still there, should not use it according to the above rule. Explicit define 2 if we want to use it.)
    Cow& operator=(const Cow& C) = delete; // Still count as copy assignment operator declared by the user
};



/* 2. C++ 11: Shared pointer */
class Dog{
    string m_name;
    public:
    Dog(string name){cout << "Dog is created: "<< name <<endl; m_name = name;}
    Dog(){cout << "Nameless dog created. " << name <<endl; m_nam = "nameless";}
    ~Dog(){cout << "Dog is destroyed: " << m_name <<endl;}
    void bark(){cout << "Dog " << m_name << "rules!" << endl;}
};
//Hard to track when to delete pointer in large project
void foo(){
    Dog* p = new Dog("Gunner");
    //...
    delete p;
    //...
    p->bark(); // p is a dangling pointer now -- undefined behavior
}// If we do not delete p, then we will have memory leak

void fooFunc(){
    //We will have a count to keep track of how many pointers are pointing to the object.
    shared_ptr<Dog> p(new Dog("Gunner")); // count == 1 now
    {
        shared_ptr<Dog> p2 = p; //count == 2
        p2->bark();
        cout << p.use_count() << endl; //Output how many pointers we have
    }
    p->bark(); //count == 1

}// count will be 0 when code executes to here

int main(){
    fooFunc();
    Dog* d = new Dog("Tank"); //Should not use
    shared_ptr<Dog> p(d); // p.get_count() == 1
    //Here when p goes out of scope, d will be destroyed. Then p2 goes out of scope, p2 will be destroyed again...
    shared_ptr<Dog> p2(d); // p2.get_count() == 1
    /* Lesson: An object should be assigned to a shrared_pointer immediately when it is created. The above case does not follow this rule. We first create the raw pointer d and then initialize p and p2 with d. We should do somthing like: shared_ptr<Dog> p(new Dog("Tank")), then shared_ptr<Dog> p2 = p.*/

    //Another way to create a shared pointer:
    shared_ptr<Dog> p = make_shared<Dog>("Thank"); //Faster and safer/ Exception safe
    (*p).bark();
    //The following function can also work on shared pointers
    // static_pointer_cast
    // dynamic_pointer_cast
    // const_pointer_cast
    return 0;
}







